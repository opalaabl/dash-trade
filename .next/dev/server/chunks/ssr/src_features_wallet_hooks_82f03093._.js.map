{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"sources":["file:///home/naufalfzml/Projects/Hackathon/dash-baseindo/dash-fe/src/features/wallet/hooks/useSessionKey.ts"],"sourcesContent":["import { useState, useEffect } from 'react';\nimport { keccak256, toHex, hashMessage, recoverMessageAddress, encodePacked } from 'viem';\nimport { privateKeyToAccount } from 'viem/accounts';\n\nexport interface SessionKey {\n  privateKey: `0x${string}`;\n  address: string;\n  expiresAt: number;\n  authorizedBy: string;\n  authSignature: string;\n  createdAt: number;\n}\n\nconst SESSION_STORAGE_KEY = 'dash_session_key';\nconst DEFAULT_SESSION_DURATION = 30 * 60 * 1000; // 30 minutes\n\nexport function useSessionKey() {\n  const [sessionKey, setSessionKey] = useState<SessionKey | null>(null);\n  const [isLoading, setIsLoading] = useState(false);\n\n  // Load session key from localStorage on mount\n  useEffect(() => {\n    const stored = localStorage.getItem(SESSION_STORAGE_KEY);\n    if (stored) {\n      try {\n        const parsed: SessionKey = JSON.parse(stored);\n        // Check if expired\n        if (parsed.expiresAt > Date.now()) {\n          setSessionKey(parsed);\n        } else {\n          localStorage.removeItem(SESSION_STORAGE_KEY);\n        }\n      } catch (err) {\n        console.error('Failed to parse session key:', err);\n        localStorage.removeItem(SESSION_STORAGE_KEY);\n      }\n    }\n  }, []);\n\n  /**\n   * Check if current session is valid (exists and not expired)\n   */\n  const isSessionValid = (): boolean => {\n    if (!sessionKey) return false;\n    if (sessionKey.expiresAt <= Date.now()) {\n      clearSession();\n      return false;\n    }\n    return true;\n  };\n\n  /**\n   * Create a new session key\n   * User must sign a message authorizing this ephemeral key\n   */\n  const createSession = async (\n    userAddress: string,\n    walletClient: any,\n    durationMs: number = DEFAULT_SESSION_DURATION,\n  ): Promise<SessionKey | null> => {\n    try {\n      setIsLoading(true);\n\n      // Generate random private key for session\n      const randomBytes = crypto.getRandomValues(new Uint8Array(32));\n      const privateKey = `0x${Array.from(randomBytes)\n        .map((b) => b.toString(16).padStart(2, '0'))\n        .join('')}` as `0x${string}`;\n\n      // Derive address from private key\n      const sessionAccount = privateKeyToAccount(privateKey);\n      const sessionAddress = sessionAccount.address;\n\n      const expiresAt = Date.now() + durationMs;\n      const expiresAtSeconds = Math.floor(expiresAt / 1000);\n\n      const authMessageHash = keccak256(\n        encodePacked(\n          ['string', 'address', 'string', 'uint256'],\n          [\n            'Authorize session key ',\n            sessionAddress as `0x${string}`,\n            ' for Dash Tap-to-Trade until ',\n            BigInt(expiresAtSeconds),\n          ],\n        ),\n      );\n\n      // User signs authorization (this is the ONLY signature needed!)\n      const authSignature = await walletClient.request({\n        method: 'personal_sign',\n        params: [authMessageHash, userAddress],\n      });\n\n      const newSession: SessionKey = {\n        privateKey,\n        address: sessionAddress,\n        expiresAt,\n        authorizedBy: userAddress.toLowerCase(),\n        authSignature: authSignature as string,\n        createdAt: Date.now(),\n      };\n\n      // Store in state and localStorage\n      setSessionKey(newSession);\n      localStorage.setItem(SESSION_STORAGE_KEY, JSON.stringify(newSession));\n\n      return newSession;\n    } catch (err: any) {\n      console.error('Session creation failed:', err);\n      return null;\n    } finally {\n      setIsLoading(false);\n    }\n  };\n\n  /**\n   * Sign a message using the session key (no user prompt!)\n   * IMPORTANT: Uses hashMessage to match ethers.verifyMessage behavior\n   */\n  const signWithSession = async (messageHash: `0x${string}`): Promise<string | null> => {\n    if (!isSessionValid()) {\n      return null;\n    }\n\n    try {\n      const sessionAccount = privateKeyToAccount(sessionKey!.privateKey);\n\n      // Hash the message with Ethereum signed message prefix\n      // This creates the same hash that ethers.verifyMessage expects\n      const digest = hashMessage({ raw: messageHash });\n\n      // Sign the digest using raw ECDSA (no additional hashing)\n      const signature = await sessionAccount.sign({ hash: digest });\n\n      return signature;\n    } catch (err) {\n      console.error('Failed to sign with session:', err);\n      return null;\n    }\n  };\n\n  /**\n   * Clear current session\n   */\n  const clearSession = () => {\n    setSessionKey(null);\n    localStorage.removeItem(SESSION_STORAGE_KEY);\n  };\n\n  /**\n   * Get time remaining in session (milliseconds)\n   */\n  const getTimeRemaining = (): number => {\n    if (!sessionKey) return 0;\n    return Math.max(0, sessionKey.expiresAt - Date.now());\n  };\n\n  return {\n    sessionKey,\n    isSessionValid,\n    createSession,\n    signWithSession,\n    clearSession,\n    getTimeRemaining,\n    isLoading,\n  };\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 151, "column": 0}, "map": {"version":3,"sources":["file:///home/naufalfzml/Projects/Hackathon/dash-baseindo/dash-fe/src/features/wallet/hooks/useEmbeddedWallet.ts"],"sourcesContent":["/**\n * Hook to get Privy embedded wallet address\n */\n\nimport { usePrivy } from '@privy-io/react-auth';\nimport { useMemo } from 'react';\n\ninterface EmbeddedWalletAccount {\n  type: string;\n  imported: boolean;\n  id?: string;\n  address: string;\n}\n\nexport function useEmbeddedWallet() {\n  const { user } = usePrivy();\n\n  const embeddedWallet = useMemo(() => {\n    if (!user?.linkedAccounts) return null;\n\n    const wallets = user.linkedAccounts.filter(\n      (account: unknown) => {\n        const acc = account as { type: string; imported: boolean; id?: string };\n        return acc.type === 'wallet' && acc.imported === false && acc.id !== undefined;\n      }\n    ) as EmbeddedWalletAccount[];\n\n    return wallets?.[0] || null;\n  }, [user]);\n\n  return {\n    address: embeddedWallet?.address as `0x${string}` | undefined,\n    hasEmbeddedWallet: !!embeddedWallet,\n    embeddedWallet,\n  };\n}\n"],"names":[],"mappings":"AAAA;;CAEC;;;;AAED;AACA;;;AASO,SAAS;IACd,MAAM,EAAE,IAAI,EAAE,GAAG,IAAA,mOAAQ;IAEzB,MAAM,iBAAiB,IAAA,gNAAO,EAAC;QAC7B,IAAI,CAAC,MAAM,gBAAgB,OAAO;QAElC,MAAM,UAAU,KAAK,cAAc,CAAC,MAAM,CACxC,CAAC;YACC,MAAM,MAAM;YACZ,OAAO,IAAI,IAAI,KAAK,YAAY,IAAI,QAAQ,KAAK,SAAS,IAAI,EAAE,KAAK;QACvE;QAGF,OAAO,SAAS,CAAC,EAAE,IAAI;IACzB,GAAG;QAAC;KAAK;IAET,OAAO;QACL,SAAS,gBAAgB;QACzB,mBAAmB,CAAC,CAAC;QACrB;IACF;AACF"}},
    {"offset": {"line": 183, "column": 0}, "map": {"version":3,"sources":["file:///home/naufalfzml/Projects/Hackathon/dash-baseindo/dash-fe/src/features/wallet/hooks/usePaymaster.ts"],"sourcesContent":["/**\n * Hooks for USDC Paymaster interactions\n */\n\nimport {\n  useReadContract,\n  useWaitForTransactionReceipt,\n  usePublicClient,\n  useWriteContract,\n} from 'wagmi';\nimport { parseUnits, formatUnits, encodeFunctionData } from 'viem';\nimport { useState, useEffect } from 'react';\nimport { baseSepolia } from 'wagmi/chains';\nimport { useWallets } from '@privy-io/react-auth';\nimport { USDC_PAYMASTER_ADDRESS, USDC_ADDRESS, USDC_DECIMALS } from '@/config/contracts';\nimport USDCPaymasterABI from '@/contracts/abis/USDCPaymaster.json';\nimport MockUSDCABI from '@/contracts/abis/MockUSDC.json';\nimport { useEmbeddedWallet } from './useEmbeddedWallet';\n\n/**\n * Hook to get user's USDC deposit balance in paymaster\n */\nexport function usePaymasterBalance() {\n  const { address } = useEmbeddedWallet();\n\n  const {\n    data: balance,\n    isLoading,\n    refetch,\n  } = useReadContract({\n    address: USDC_PAYMASTER_ADDRESS,\n    abi: USDCPaymasterABI,\n    functionName: 'getUserDeposit',\n    args: address ? [address] : undefined,\n    query: {\n      enabled: !!address,\n    },\n  });\n\n  return {\n    balance: balance ? formatUnits(balance as bigint, USDC_DECIMALS) : '0',\n    balanceRaw: balance as bigint | undefined,\n    isLoading,\n    refetch,\n  };\n}\n\n/**\n * Hook to deposit USDC to paymaster\n */\nexport function useDepositToPaymaster() {\n  const { address } = useEmbeddedWallet();\n  const { wallets } = useWallets();\n  const [hash, setHash] = useState<`0x${string}` | undefined>();\n  const [isPending, setIsPending] = useState(false);\n  const [error, setError] = useState<Error | null>(null);\n  const { isLoading: isConfirming, isSuccess } = useWaitForTransactionReceipt({\n    hash,\n  });\n\n  const deposit = async (amount: string) => {\n    try {\n      setIsPending(true);\n      setError(null);\n\n      const embeddedWallet = wallets.find(\n        (w) => w.walletClientType === 'privy' && w.address === address,\n      );\n\n      if (!embeddedWallet) {\n        throw new Error('Embedded wallet not found');\n      }\n\n      await embeddedWallet.switchChain(baseSepolia.id);\n      const walletClient = await embeddedWallet.getEthereumProvider();\n\n      if (!walletClient) {\n        throw new Error('Could not get wallet client');\n      }\n\n      const amountBigInt = parseUnits(amount, USDC_DECIMALS);\n\n      const data = encodeFunctionData({\n        abi: USDCPaymasterABI,\n        functionName: 'deposit',\n        args: [amountBigInt],\n      });\n\n      const txHash = await walletClient.request({\n        method: 'eth_sendTransaction',\n        params: [\n          {\n            from: address,\n            to: USDC_PAYMASTER_ADDRESS,\n            data,\n          },\n        ],\n      });\n\n      setHash(txHash as `0x${string}`);\n    } catch (err) {\n      console.error('❌ Deposit error:', err);\n      setError(err as Error);\n    } finally {\n      setIsPending(false);\n    }\n  };\n\n  return {\n    deposit,\n    isPending,\n    isConfirming,\n    isSuccess,\n    error,\n    hash,\n  };\n}\n\n/**\n * Hook to withdraw USDC from paymaster\n */\nexport function useWithdrawFromPaymaster() {\n  const { writeContractAsync, data: hash, isPending, error } = useWriteContract();\n  const { isLoading: isConfirming, isSuccess } = useWaitForTransactionReceipt({\n    hash,\n  });\n\n  const withdraw = async (amount: string) => {\n    const amountBigInt = parseUnits(amount, USDC_DECIMALS);\n\n    await writeContractAsync({\n      address: USDC_PAYMASTER_ADDRESS,\n      abi: USDCPaymasterABI,\n      functionName: 'withdraw',\n      args: [amountBigInt],\n      chainId: baseSepolia.id,\n    });\n  };\n\n  return {\n    withdraw,\n    isPending,\n    isConfirming,\n    isSuccess,\n    error,\n    hash,\n  };\n}\n\n/**\n * Hook to check and approve USDC for paymaster\n */\nexport function useApproveUSDCForPaymaster() {\n  const { address } = useEmbeddedWallet();\n  const { wallets } = useWallets();\n  const [hash, setHash] = useState<`0x${string}` | undefined>();\n  const [isPending, setIsPending] = useState(false);\n  const [error, setError] = useState<Error | null>(null);\n  const { isLoading: isConfirming, isSuccess } = useWaitForTransactionReceipt({\n    hash,\n  });\n\n  // Check current allowance\n  const { data: allowance, refetch: refetchAllowance } = useReadContract({\n    address: USDC_ADDRESS,\n    abi: MockUSDCABI,\n    functionName: 'allowance',\n    args: address ? [address, USDC_PAYMASTER_ADDRESS] : undefined,\n    query: {\n      enabled: !!address,\n    },\n  });\n\n  const approve = async (amount: string) => {\n    try {\n      setIsPending(true);\n      setError(null);\n\n      // Find embedded wallet\n      const embeddedWallet = wallets.find(\n        (w) => w.walletClientType === 'privy' && w.address === address,\n      );\n\n      if (!embeddedWallet) {\n        throw new Error('Embedded wallet not found');\n      }\n\n      const amountBigInt = parseUnits(amount, USDC_DECIMALS);\n\n      // Switch to correct chain first\n      await embeddedWallet.switchChain(baseSepolia.id);\n\n      // Get wallet client\n      const walletClient = await embeddedWallet.getEthereumProvider();\n\n      if (!walletClient) {\n        throw new Error('Could not get wallet client');\n      }\n\n      // Encode approve function call\n      const data = encodeFunctionData({\n        abi: MockUSDCABI,\n        functionName: 'approve',\n        args: [USDC_PAYMASTER_ADDRESS, amountBigInt],\n      });\n\n      // Send transaction using provider\n      const txHash = await walletClient.request({\n        method: 'eth_sendTransaction',\n        params: [\n          {\n            from: address,\n            to: USDC_ADDRESS,\n            data,\n          },\n        ],\n      });\n\n      setHash(txHash as `0x${string}`);\n    } catch (err) {\n      console.error('❌ Approve error:', err);\n      setError(err as Error);\n    } finally {\n      setIsPending(false);\n    }\n  };\n\n  const hasAllowance = (requiredAmount: string): boolean => {\n    if (!allowance) return false;\n    const required = parseUnits(requiredAmount, USDC_DECIMALS);\n    return (allowance as bigint) >= required;\n  };\n\n  return {\n    approve,\n    isPending,\n    isConfirming,\n    isSuccess,\n    error,\n    hash,\n    allowance: allowance as bigint | undefined,\n    hasAllowance,\n    refetchAllowance,\n  };\n}\n\n/**\n * Hook to get paymaster exchange rate info\n */\nexport function usePaymasterRateInfo() {\n  const { data, isLoading, refetch } = useReadContract({\n    address: USDC_PAYMASTER_ADDRESS,\n    abi: USDCPaymasterABI,\n    functionName: 'getRateInfo',\n  });\n\n  const rateData = data as [bigint, bigint] | undefined;\n\n  return {\n    usdcPerEth: rateData?.[0],\n    premiumBps: rateData?.[1],\n    isLoading,\n    refetch,\n  };\n}\n\n/**\n * Hook to calculate USDC cost for gas\n */\nexport function useCalculateGasCost(gasAmount: bigint | undefined) {\n  const { data: cost, isLoading } = useReadContract({\n    address: USDC_PAYMASTER_ADDRESS,\n    abi: USDCPaymasterABI,\n    functionName: 'calculateUsdcCost',\n    args: gasAmount ? [gasAmount] : undefined,\n    query: {\n      enabled: !!gasAmount && gasAmount > 0n,\n    },\n  });\n\n  return {\n    cost: cost as bigint | undefined,\n    costFormatted: cost ? formatUnits(cost as bigint, USDC_DECIMALS) : '0',\n    isLoading,\n  };\n}\n\n/**\n * Combined hook for paymaster flow management\n */\nexport function usePaymasterFlow() {\n  const [isApproving, setIsApproving] = useState(false);\n  const [isDepositing, setIsDepositing] = useState(false);\n\n  const { balance, balanceRaw, refetch: refetchBalance } = usePaymasterBalance();\n  const {\n    approve,\n    isSuccess: isApproveSuccess,\n    hasAllowance,\n    refetchAllowance,\n  } = useApproveUSDCForPaymaster();\n  const { deposit, isSuccess: isDepositSuccess } = useDepositToPaymaster();\n\n  // Refetch balance when deposit is successful\n  useEffect(() => {\n    if (isDepositSuccess) {\n      refetchBalance();\n      setIsDepositing(false);\n    }\n  }, [isDepositSuccess, refetchBalance]);\n\n  // Refetch allowance when approve is successful\n  useEffect(() => {\n    if (isApproveSuccess) {\n      refetchAllowance();\n      setIsApproving(false);\n    }\n  }, [isApproveSuccess, refetchAllowance]);\n\n  /**\n   * Ensure paymaster has sufficient balance\n   * Will approve and deposit if needed\n   */\n  const ensurePaymasterBalance = async (requiredAmount: string): Promise<boolean> => {\n    try {\n      // Check if balance is sufficient\n      const balanceNum = parseFloat(balance);\n      const requiredNum = parseFloat(requiredAmount);\n\n      if (balanceNum >= requiredNum) {\n        return true; // Already have enough balance\n      }\n\n      const depositAmount = (requiredNum - balanceNum + 10).toFixed(6); // Add 10 USDC buffer\n\n      // Check allowance\n      if (!hasAllowance(depositAmount)) {\n        setIsApproving(true);\n        await approve(depositAmount);\n        // Wait for approval to complete\n        return false; // Need to retry after approval\n      }\n\n      // Deposit\n      setIsDepositing(true);\n      await deposit(depositAmount);\n      return false; // Need to wait for deposit to complete\n    } catch (error) {\n      console.error('Error ensuring paymaster balance:', error);\n      setIsApproving(false);\n      setIsDepositing(false);\n      return false;\n    }\n  };\n\n  return {\n    balance,\n    balanceRaw,\n    isApproving,\n    isDepositing,\n    ensurePaymasterBalance,\n    refetchBalance,\n  };\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 511, "column": 0}, "map": {"version":3,"sources":["file:///home/naufalfzml/Projects/Hackathon/dash-baseindo/dash-fe/src/features/wallet/hooks/useTapToTradeApproval.ts"],"sourcesContent":["import { useState, useEffect, useCallback } from 'react';\nimport { usePrivy, useWallets } from '@privy-io/react-auth';\nimport { parseUnits, formatUnits } from 'viem';\nimport { USDC_ADDRESS, TAP_TO_TRADE_EXECUTOR_ADDRESS, USDC_DECIMALS } from '@/config/contracts';\n\nconst USDC_ABI = [\n  {\n    inputs: [\n      { name: 'spender', type: 'address' },\n      { name: 'amount', type: 'uint256' },\n    ],\n    name: 'approve',\n    outputs: [{ name: '', type: 'bool' }],\n    stateMutability: 'nonpayable',\n    type: 'function',\n  },\n  {\n    inputs: [\n      { name: 'owner', type: 'address' },\n      { name: 'spender', type: 'address' },\n    ],\n    name: 'allowance',\n    outputs: [{ name: '', type: 'uint256' }],\n    stateMutability: 'view',\n    type: 'function',\n  },\n];\n\n/**\n * Hook for USDC approval specifically for TapToTradeExecutor contract\n */\nexport function useTapToTradeApproval() {\n  const { authenticated } = usePrivy();\n  const { wallets, ready: walletsReady } = useWallets();\n  const [allowance, setAllowance] = useState<bigint | null>(null);\n  const [isPending, setIsPending] = useState(false);\n  const [isLoading, setIsLoading] = useState(false);\n\n  /**\n   * Fetch current USDC allowance for TapToTradeExecutor\n   */\n  const fetchAllowance = useCallback(async () => {\n    if (!authenticated || !walletsReady) return;\n\n    try {\n      const embeddedWallet = wallets.find((w) => w.walletClientType === 'privy');\n      if (!embeddedWallet) return;\n\n      const walletClient = await embeddedWallet.getEthereumProvider();\n      if (!walletClient) return;\n\n      const userAddress = embeddedWallet.address;\n\n      // Encode allowance call\n      const allowanceData = `0xdd62ed3e${userAddress\n        .slice(2)\n        .padStart(64, '0')}${TAP_TO_TRADE_EXECUTOR_ADDRESS.slice(2).padStart(64, '0')}`;\n\n      const result = await walletClient.request({\n        method: 'eth_call',\n        params: [\n          {\n            to: USDC_ADDRESS,\n            data: allowanceData,\n          },\n          'latest',\n        ],\n      });\n\n      const allowanceValue = result === '0x' || !result ? BigInt(0) : BigInt(result as string);\n      setAllowance(allowanceValue);\n    } catch (error) {\n      setAllowance(BigInt(0));\n    }\n  }, [authenticated, walletsReady, wallets]);\n\n  /**\n   * Approve USDC for TapToTradeExecutor\n   */\n  const approve = useCallback(\n    async (amount: string) => {\n      if (!authenticated || !walletsReady) {\n        throw new Error('Wallet not ready');\n      }\n\n      const embeddedWallet = wallets.find((w) => w.walletClientType === 'privy');\n      if (!embeddedWallet) {\n        throw new Error('Embedded wallet not found');\n      }\n\n      setIsPending(true);\n\n      try {\n        const walletClient = await embeddedWallet.getEthereumProvider();\n        if (!walletClient) {\n          throw new Error('Wallet client not available');\n        }\n\n        // Encode approve function call\n        const approveData = `0x095ea7b3${TAP_TO_TRADE_EXECUTOR_ADDRESS.slice(2).padStart(\n          64,\n          '0',\n        )}${BigInt(amount).toString(16).padStart(64, '0')}`;\n\n        const txHash = await walletClient.request({\n          method: 'eth_sendTransaction',\n          params: [\n            {\n              from: embeddedWallet.address,\n              to: USDC_ADDRESS,\n              data: approveData,\n            },\n          ],\n        });\n\n        // Wait for confirmation\n        let confirmed = false;\n        let attempts = 0;\n        while (!confirmed && attempts < 30) {\n          await new Promise((resolve) => setTimeout(resolve, 2000));\n          const receipt = await walletClient.request({\n            method: 'eth_getTransactionReceipt',\n            params: [txHash],\n          });\n\n          if (receipt && (receipt as any).status === '0x1') {\n            confirmed = true;\n          }\n          attempts++;\n        }\n\n        if (!confirmed) {\n          throw new Error('Transaction confirmation timeout');\n        }\n\n        // Refresh allowance\n        await fetchAllowance();\n\n        return txHash;\n      } catch (error: any) {\n        throw error;\n      } finally {\n        setIsPending(false);\n      }\n    },\n    [authenticated, walletsReady, wallets, fetchAllowance],\n  );\n\n  /**\n   * Check if user has sufficient allowance (> threshold)\n   */\n  const hasAllowance = useCallback(\n    (threshold: bigint = parseUnits('10000', USDC_DECIMALS)) => {\n      return allowance !== null && allowance > threshold;\n    },\n    [allowance],\n  );\n\n  // Fetch allowance on mount and when dependencies change\n  useEffect(() => {\n    if (authenticated && walletsReady) {\n      fetchAllowance();\n    }\n  }, [authenticated, walletsReady, fetchAllowance]);\n\n  return {\n    allowance,\n    approve,\n    hasAllowance,\n    isPending,\n    isLoading,\n    refetch: fetchAllowance,\n  };\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 697, "column": 0}, "map": {"version":3,"sources":["file:///home/naufalfzml/Projects/Hackathon/dash-baseindo/dash-fe/src/features/wallet/hooks/useOneTapProfitApproval.ts"],"sourcesContent":["'use client';\n\nimport { useState, useEffect, useCallback } from 'react';\nimport { usePrivy, useWallets } from '@privy-io/react-auth';\nimport { createWalletClient, custom, encodeFunctionData, parseUnits } from 'viem';\nimport { baseSepolia } from 'viem/chains';\n\nconst USDC_ADDRESS = process.env.NEXT_PUBLIC_USDC_TOKEN_ADDRESS as `0x${string}`;\nconst ONE_TAP_PROFIT_ADDRESS = process.env.NEXT_PUBLIC_ONE_TAP_PROFIT_ADDRESS as `0x${string}`;\n\nconst USDC_ABI = [\n  {\n    inputs: [\n      { name: 'spender', type: 'address' },\n      { name: 'amount', type: 'uint256' },\n    ],\n    name: 'approve',\n    outputs: [{ name: '', type: 'bool' }],\n    stateMutability: 'nonpayable',\n    type: 'function',\n  },\n  {\n    inputs: [\n      { name: 'owner', type: 'address' },\n      { name: 'spender', type: 'address' },\n    ],\n    name: 'allowance',\n    outputs: [{ name: '', type: 'uint256' }],\n    stateMutability: 'view',\n    type: 'function',\n  },\n] as const;\n\nexport const useOneTapProfitApproval = () => {\n  const { authenticated } = usePrivy();\n  const { wallets } = useWallets();\n  const [allowance, setAllowance] = useState<bigint | null>(null);\n  const [isPending, setIsPending] = useState(false);\n  const [isLoading, setIsLoading] = useState(false);\n\n  const embeddedWallet = wallets.find((w) => w.walletClientType === 'privy');\n\n  // Check current allowance\n  const checkAllowance = useCallback(async () => {\n    if (!authenticated || !embeddedWallet) {\n      setAllowance(null);\n      return;\n    }\n\n    try {\n      setIsLoading(true);\n      const ethereumProvider = await embeddedWallet.getEthereumProvider();\n      const userAddress = embeddedWallet.address as `0x${string}`;\n\n      const allowanceData = encodeFunctionData({\n        abi: USDC_ABI,\n        functionName: 'allowance',\n        args: [userAddress, ONE_TAP_PROFIT_ADDRESS],\n      });\n\n      const result = await ethereumProvider.request({\n        method: 'eth_call',\n        params: [\n          {\n            to: USDC_ADDRESS,\n            data: allowanceData,\n          },\n          'latest',\n        ],\n      });\n\n      const currentAllowance = BigInt(result as string);\n      setAllowance(currentAllowance);\n    } catch (error) {\n      console.error('Failed to check OneTapProfit allowance:', error);\n      setAllowance(null);\n    } finally {\n      setIsLoading(false);\n    }\n  }, [authenticated, embeddedWallet]);\n\n  // Auto-check allowance on mount and when wallet changes\n  useEffect(() => {\n    checkAllowance();\n  }, [checkAllowance]);\n\n  // Approve USDC spending\n  const approve = useCallback(\n    async (amount: string) => {\n      if (!authenticated || !embeddedWallet) {\n        throw new Error('Wallet not connected');\n      }\n\n      setIsPending(true);\n\n      try {\n        const ethereumProvider = await embeddedWallet.getEthereumProvider();\n        const userAddress = embeddedWallet.address as `0x${string}`;\n\n        const walletClient = createWalletClient({\n          account: userAddress,\n          chain: baseSepolia,\n          transport: custom(ethereumProvider),\n        });\n\n        const approveData = encodeFunctionData({\n          abi: USDC_ABI,\n          functionName: 'approve',\n          args: [ONE_TAP_PROFIT_ADDRESS, BigInt(amount)],\n        });\n\n        const txHash = await walletClient.sendTransaction({\n          account: userAddress,\n          to: USDC_ADDRESS,\n          data: approveData,\n        });\n\n        // Wait a bit for transaction to be mined\n        await new Promise((resolve) => setTimeout(resolve, 3000));\n\n        // Refresh allowance\n        await checkAllowance();\n\n        return txHash;\n      } catch (error) {\n        console.error('Failed to approve USDC for OneTapProfit:', error);\n        throw error;\n      } finally {\n        setIsPending(false);\n      }\n    },\n    [authenticated, embeddedWallet, checkAllowance],\n  );\n\n  // Check if user has sufficient allowance for a specific amount\n  const hasAllowance = useCallback(\n    (requiredAmount?: string) => {\n      if (!allowance) return false;\n      if (!requiredAmount) return allowance > 0n;\n\n      try {\n        const required = parseUnits(requiredAmount, 6);\n        return allowance >= required;\n      } catch {\n        return false;\n      }\n    },\n    [allowance],\n  );\n\n  return {\n    allowance,\n    hasAllowance,\n    approve,\n    isPending,\n    isLoading,\n    checkAllowance,\n  };\n};\n"],"names":[],"mappings":"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"}}]
}
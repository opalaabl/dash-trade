{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"sources":["file:///home/naufalfzml/Projects/Hackathon/dash-baseindo/dash-fe/src/types/gridTrading.ts"],"sourcesContent":["// Grid Trading Types\n\nexport interface GridConfig {\n  // X-axis (Time) configuration\n  timeMultiplier: number; // Multiplier untuk timeframe (e.g., 2 = 2x interval)\n  \n  // Y-axis (Price) configuration\n  priceGridSize: number; // Size of each price grid in percentage or absolute value\n  priceGridType: 'percentage' | 'absolute'; // Type of price grid\n  \n  // Grid display\n  enabled: boolean;\n  showLabels: boolean;\n}\n\nexport interface GridCell {\n  id: string;\n  timeIndex: number; // Index dalam array candle\n  priceLevel: number; // Price level dari grid cell\n  timestamp: number; // Unix timestamp\n  isAboveCurrentPrice: boolean; // true = limit sell, false = limit buy\n}\n\nexport interface GridOrder {\n  cellId: string;\n  orderType: 'buy' | 'sell';\n  price: number;\n  amount: number;\n  timestamp: number;\n  status: 'pending' | 'filled' | 'cancelled';\n}\n\nexport interface TapToTradeState {\n  selectedCells: Set<string>;\n  pendingOrders: GridOrder[];\n  gridConfig: GridConfig;\n}\n\n// Default configuration\nexport const DEFAULT_GRID_CONFIG: GridConfig = {\n  timeMultiplier: 1,\n  priceGridSize: 0.5, // 0.5% per grid\n  priceGridType: 'percentage',\n  enabled: false,\n  showLabels: true,\n};\n"],"names":[],"mappings":"AAAA,qBAAqB;;;;;AAuCd,MAAM,sBAAkC;IAC7C,gBAAgB;IAChB,eAAe;IACf,eAAe;IACf,SAAS;IACT,YAAY;AACd"}},
    {"offset": {"line": 23, "column": 0}, "map": {"version":3,"sources":["file:///home/naufalfzml/Projects/Hackathon/dash-baseindo/dash-fe/src/contexts/GridTradingContext.tsx"],"sourcesContent":["'use client';\n\nimport React, { createContext, useContext, ReactNode } from 'react';\nimport { useGridTrading as useGridTradingUI } from '@/features/trading/hooks/useGridTradingUI';\n\ntype GridTradingContextType = ReturnType<typeof useGridTradingUI>;\n\nconst GridTradingContext = createContext<GridTradingContextType | null>(null);\n\nexport const GridTradingProvider: React.FC<{ children: ReactNode }> = ({ children }) => {\n  const gridTrading = useGridTradingUI({ currentPrice: 0, interval: '60' });\n\n  return <GridTradingContext.Provider value={gridTrading}>{children}</GridTradingContext.Provider>;\n};\n\nexport const useGridTradingContext = (): GridTradingContextType => {\n  const context = useContext(GridTradingContext);\n  if (!context) {\n    throw new Error('useGridTradingContext must be used within GridTradingProvider');\n  }\n  return context;\n};\n"],"names":[],"mappings":";;;;;;;AAEA;AACA;;;AAHA;;;AAOA,MAAM,mCAAqB,IAAA,8KAAa,EAAgC;AAEjE,MAAM,sBAAyD,CAAC,EAAE,QAAQ,EAAE;;IACjF,MAAM,cAAc,IAAA,4KAAgB,EAAC;QAAE,cAAc;QAAG,UAAU;IAAK;IAEvE,qBAAO,6LAAC,mBAAmB,QAAQ;QAAC,OAAO;kBAAc;;;;;;AAC3D;GAJa;;QACS,4KAAgB;;;KADzB;AAMN,MAAM,wBAAwB;;IACnC,MAAM,UAAU,IAAA,2KAAU,EAAC;IAC3B,IAAI,CAAC,SAAS;QACZ,MAAM,IAAI,MAAM;IAClB;IACA,OAAO;AACT;IANa"}},
    {"offset": {"line": 77, "column": 0}, "map": {"version":3,"sources":["file:///home/naufalfzml/Projects/Hackathon/dash-baseindo/dash-fe/src/hooks/data/useUSDCBalance.ts"],"sourcesContent":["import { useEffect, useState } from 'react';\nimport { usePrivy } from '@privy-io/react-auth';\nimport { createPublicClient, http, formatUnits } from 'viem';\nimport { baseSepolia } from 'wagmi/chains';\nimport { USDC_ADDRESS, USDC_DECIMALS } from '@/config/contracts';\n\n/**\n * Custom hook to fetch USDC balance from the embedded wallet\n * Uses the same logic as WalletConnectButton to ensure consistency\n */\nexport const useUSDCBalance = () => {\n  const { authenticated, user } = usePrivy();\n  const [usdcBalance, setUsdcBalance] = useState<string>('0.00');\n  const [isLoadingBalance, setIsLoadingBalance] = useState(false);\n\n  useEffect(() => {\n    const fetchUsdcBalance = async () => {\n      if (!authenticated || !user) {\n        setUsdcBalance('0.00');\n        return;\n      }\n\n      // Get embedded wallet address (same logic as WalletConnectButton)\n      const embeddedWallets = user.linkedAccounts?.filter(\n        (account: any) =>\n          account.type === 'wallet' && account.imported === false && account.id !== undefined,\n      ) as any[];\n\n      const embeddedWalletAddress = embeddedWallets?.[0]?.address || user?.wallet?.address;\n\n      if (!embeddedWalletAddress) {\n        setUsdcBalance('0.00');\n        return;\n      }\n\n      setIsLoadingBalance(true);\n      try {\n        const publicClient = createPublicClient({\n          chain: baseSepolia,\n          transport: http(),\n        });\n\n        const balance = (await publicClient.readContract({\n          address: USDC_ADDRESS,\n          abi: [\n            {\n              constant: true,\n              inputs: [{ name: '_owner', type: 'address' }],\n              name: 'balanceOf',\n              outputs: [{ name: 'balance', type: 'uint256' }],\n              type: 'function',\n            },\n          ],\n          functionName: 'balanceOf',\n          args: [embeddedWalletAddress as `0x${string}`],\n        })) as bigint;\n\n        // Format USDC balance using configured decimals\n        const formattedBalance = formatUnits(balance, USDC_DECIMALS);\n        setUsdcBalance(parseFloat(formattedBalance).toFixed(2));\n      } catch (error) {\n        setUsdcBalance('0.00');\n      } finally {\n        setIsLoadingBalance(false);\n      }\n    };\n\n    if (authenticated && user) {\n      fetchUsdcBalance();\n\n      // Refresh balance every 5 seconds to keep it in sync\n      const interval = setInterval(fetchUsdcBalance, 5000);\n      return () => clearInterval(interval);\n    }\n  }, [authenticated, user]);\n\n  return { usdcBalance, isLoadingBalance };\n};\n"],"names":[],"mappings":";;;;AAAA;AACA;AACA;AAAA;AAAA;AACA;AACA;;;;;;;AAMO,MAAM,iBAAiB;;IAC5B,MAAM,EAAE,aAAa,EAAE,IAAI,EAAE,GAAG,IAAA,sOAAQ;IACxC,MAAM,CAAC,aAAa,eAAe,GAAG,IAAA,yKAAQ,EAAS;IACvD,MAAM,CAAC,kBAAkB,oBAAoB,GAAG,IAAA,yKAAQ,EAAC;IAEzD,IAAA,0KAAS;oCAAC;YACR,MAAM;6DAAmB;oBACvB,IAAI,CAAC,iBAAiB,CAAC,MAAM;wBAC3B,eAAe;wBACf;oBACF;oBAEA,kEAAkE;oBAClE,MAAM,kBAAkB,KAAK,cAAc,EAAE;qEAC3C,CAAC,UACC,QAAQ,IAAI,KAAK,YAAY,QAAQ,QAAQ,KAAK,SAAS,QAAQ,EAAE,KAAK;;oBAG9E,MAAM,wBAAwB,iBAAiB,CAAC,EAAE,EAAE,WAAW,MAAM,QAAQ;oBAE7E,IAAI,CAAC,uBAAuB;wBAC1B,eAAe;wBACf;oBACF;oBAEA,oBAAoB;oBACpB,IAAI;wBACF,MAAM,eAAe,IAAA,sLAAkB,EAAC;4BACtC,OAAO,sLAAW;4BAClB,WAAW,IAAA,wKAAI;wBACjB;wBAEA,MAAM,UAAW,MAAM,aAAa,YAAY,CAAC;4BAC/C,SAAS,6IAAY;4BACrB,KAAK;gCACH;oCACE,UAAU;oCACV,QAAQ;wCAAC;4CAAE,MAAM;4CAAU,MAAM;wCAAU;qCAAE;oCAC7C,MAAM;oCACN,SAAS;wCAAC;4CAAE,MAAM;4CAAW,MAAM;wCAAU;qCAAE;oCAC/C,MAAM;gCACR;6BACD;4BACD,cAAc;4BACd,MAAM;gCAAC;6BAAuC;wBAChD;wBAEA,gDAAgD;wBAChD,MAAM,mBAAmB,IAAA,8KAAW,EAAC,SAAS,8IAAa;wBAC3D,eAAe,WAAW,kBAAkB,OAAO,CAAC;oBACtD,EAAE,OAAO,OAAO;wBACd,eAAe;oBACjB,SAAU;wBACR,oBAAoB;oBACtB;gBACF;;YAEA,IAAI,iBAAiB,MAAM;gBACzB;gBAEA,qDAAqD;gBACrD,MAAM,WAAW,YAAY,kBAAkB;gBAC/C;gDAAO,IAAM,cAAc;;YAC7B;QACF;mCAAG;QAAC;QAAe;KAAK;IAExB,OAAO;QAAE;QAAa;IAAiB;AACzC;GAnEa;;QACqB,sOAAQ"}},
    {"offset": {"line": 188, "column": 0}, "map": {"version":3,"sources":["file:///home/naufalfzml/Projects/Hackathon/dash-baseindo/dash-fe/src/hooks/data/usePositions.ts"],"sourcesContent":["/**\n * Hook to fetch and manage user positions\n */\n\nimport { useReadContract } from 'wagmi';\nimport { POSITION_MANAGER_ADDRESS } from '@/config/contracts';\nimport PositionManagerABI from '@/contracts/abis/PositionManager.json';\nimport { useEmbeddedWallet } from '@/features/wallet/hooks/useEmbeddedWallet';\n\nexport interface Position {\n  id: bigint;\n  trader: string;\n  symbol: string;\n  isLong: boolean;\n  collateral: bigint;\n  size: bigint;\n  leverage: bigint;\n  entryPrice: bigint;\n  openTimestamp: bigint;\n  status: number; // 0 = OPEN, 1 = CLOSED, 2 = LIQUIDATED\n}\n\n/**\n * Hook to get all user positions\n */\nexport function useUserPositions() {\n  const { address } = useEmbeddedWallet();\n\n  const {\n    data: positionIds,\n    isLoading: isLoadingIds,\n    refetch: refetchIds,\n  } = useReadContract({\n    address: POSITION_MANAGER_ADDRESS,\n    abi: PositionManagerABI,\n    functionName: 'getUserPositions',\n    args: address ? [address] : undefined,\n    query: {\n      enabled: !!address,\n      refetchInterval: 5000, // Refetch every 5 seconds\n    },\n  });\n\n  return {\n    positionIds: (positionIds as bigint[]) || [],\n    isLoading: isLoadingIds,\n    refetch: refetchIds,\n  };\n}\n\n/**\n * Hook to get single position details\n */\nexport function usePosition(positionId: bigint | undefined) {\n  const { data, isLoading, refetch } = useReadContract({\n    address: POSITION_MANAGER_ADDRESS,\n    abi: PositionManagerABI,\n    functionName: 'getPosition',\n    args: positionId !== undefined ? [positionId] : undefined,\n    query: {\n      enabled: positionId !== undefined,\n      refetchInterval: 5000, // Refetch every 5 seconds\n    },\n  });\n\n  // Parse position data from tuple\n  if (!data) {\n    return {\n      position: null,\n      isLoading,\n      refetch,\n    };\n  }\n\n  // Try to parse as object first (wagmi v2 returns objects for structs)\n  let position: Position;\n\n  if (typeof data === 'object' && !Array.isArray(data)) {\n    // Data is returned as an object with named properties\n    const dataObj = data as any;\n\n    // Check if data has properties or is just keys (0,1,2,3...)\n    // Wagmi sometimes returns object with numeric keys like {0: value, 1: value2}\n    const hasNumericKeys = '0' in dataObj && '1' in dataObj;\n\n    if (hasNumericKeys) {\n      // Object with numeric keys - treat as array\n      position = {\n        id: dataObj[0],\n        trader: dataObj[1],\n        symbol: dataObj[2],\n        isLong: dataObj[3],\n        collateral: dataObj[4],\n        size: dataObj[5],\n        leverage: dataObj[6],\n        entryPrice: dataObj[7],\n        openTimestamp: dataObj[8],\n        status: dataObj[9],\n      };\n    } else {\n      // Object with named properties\n      position = {\n        id: dataObj.id,\n        trader: dataObj.trader,\n        symbol: dataObj.symbol,\n        isLong: dataObj.isLong,\n        collateral: dataObj.collateral,\n        size: dataObj.size,\n        leverage: dataObj.leverage,\n        entryPrice: dataObj.entryPrice,\n        openTimestamp: dataObj.openTimestamp,\n        status: dataObj.status,\n      };\n    }\n  } else {\n    // Data is returned as an array (fallback)\n    const positionArray = data as any[];\n    position = {\n      id: positionArray[0],\n      trader: positionArray[1],\n      symbol: positionArray[2],\n      isLong: positionArray[3],\n      collateral: positionArray[4],\n      size: positionArray[5],\n      leverage: positionArray[6],\n      entryPrice: positionArray[7],\n      openTimestamp: positionArray[8],\n      status: positionArray[9],\n    };\n  }\n\n  // Check if position has valid data\n  if (!position.id || position.id === 0n) {\n    return {\n      position: null,\n      isLoading,\n      refetch,\n    };\n  }\n\n  return {\n    position,\n    isLoading,\n    refetch,\n  };\n}\n\n/**\n * Hook to get all user positions with full details\n * Fetches each position individually since batch function may not exist\n */\nexport function useUserPositionsWithDetails() {\n  const { positionIds, isLoading: isLoadingIds, refetch: refetchIds } = useUserPositions();\n\n  // For now, just use the position IDs and fetch them individually in the component\n  // This is a simpler approach that doesn't require a batch function\n  return {\n    positions: [],\n    positionIds,\n    allPositions: [],\n    isLoading: isLoadingIds,\n    refetch: refetchIds,\n  };\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 353, "column": 0}, "map": {"version":3,"sources":["file:///home/naufalfzml/Projects/Hackathon/dash-baseindo/dash-fe/src/hooks/wallet/useWalletBalance.ts"],"sourcesContent":["import { useState, useEffect } from 'react';\nimport { usePrivy } from '@privy-io/react-auth';\nimport { createPublicClient, http, formatUnits } from 'viem';\nimport { baseSepolia } from 'wagmi/chains';\nimport { USDC_ADDRESS, USDC_DECIMALS } from '@/config/contracts';\n\nexport const useWalletBalance = () => {\n  const { authenticated, user } = usePrivy();\n  const [usdcBalance, setUsdcBalance] = useState<string | null>(null);\n  const [isLoadingBalance, setIsLoadingBalance] = useState(false);\n\n  useEffect(() => {\n    const fetchUsdcBalance = async () => {\n      if (!authenticated || !user) return;\n\n      const embeddedWallets = user.linkedAccounts?.filter(\n        (account: any) =>\n          account.type === 'wallet' && account.imported === false && account.id !== undefined,\n      ) as any[];\n\n      const embeddedWalletAddress = embeddedWallets?.[0]?.address || user?.wallet?.address;\n\n      if (!embeddedWalletAddress) return;\n\n      setIsLoadingBalance(true);\n      try {\n        const publicClient = createPublicClient({\n          chain: baseSepolia,\n          transport: http(),\n        });\n\n        const balance = (await publicClient.readContract({\n          address: USDC_ADDRESS,\n          abi: [\n            {\n              constant: true,\n              inputs: [{ name: '_owner', type: 'address' }],\n              name: 'balanceOf',\n              outputs: [{ name: 'balance', type: 'uint256' }],\n              type: 'function',\n            },\n          ],\n          functionName: 'balanceOf',\n          args: [embeddedWalletAddress as `0x${string}`],\n        })) as bigint;\n\n        const formattedBalance = formatUnits(balance, USDC_DECIMALS);\n        setUsdcBalance(parseFloat(formattedBalance).toFixed(2));\n      } catch (error) {\n        setUsdcBalance('0.00');\n      } finally {\n        setIsLoadingBalance(false);\n      }\n    };\n\n    if (authenticated && user) {\n      fetchUsdcBalance();\n    }\n  }, [authenticated, user]);\n\n  return { usdcBalance, isLoadingBalance };\n};\n"],"names":[],"mappings":";;;;AAAA;AACA;AACA;AAAA;AAAA;AACA;AACA;;;;;;;AAEO,MAAM,mBAAmB;;IAC9B,MAAM,EAAE,aAAa,EAAE,IAAI,EAAE,GAAG,IAAA,sOAAQ;IACxC,MAAM,CAAC,aAAa,eAAe,GAAG,IAAA,yKAAQ,EAAgB;IAC9D,MAAM,CAAC,kBAAkB,oBAAoB,GAAG,IAAA,yKAAQ,EAAC;IAEzD,IAAA,0KAAS;sCAAC;YACR,MAAM;+DAAmB;oBACvB,IAAI,CAAC,iBAAiB,CAAC,MAAM;oBAE7B,MAAM,kBAAkB,KAAK,cAAc,EAAE;uEAC3C,CAAC,UACC,QAAQ,IAAI,KAAK,YAAY,QAAQ,QAAQ,KAAK,SAAS,QAAQ,EAAE,KAAK;;oBAG9E,MAAM,wBAAwB,iBAAiB,CAAC,EAAE,EAAE,WAAW,MAAM,QAAQ;oBAE7E,IAAI,CAAC,uBAAuB;oBAE5B,oBAAoB;oBACpB,IAAI;wBACF,MAAM,eAAe,IAAA,sLAAkB,EAAC;4BACtC,OAAO,sLAAW;4BAClB,WAAW,IAAA,wKAAI;wBACjB;wBAEA,MAAM,UAAW,MAAM,aAAa,YAAY,CAAC;4BAC/C,SAAS,6IAAY;4BACrB,KAAK;gCACH;oCACE,UAAU;oCACV,QAAQ;wCAAC;4CAAE,MAAM;4CAAU,MAAM;wCAAU;qCAAE;oCAC7C,MAAM;oCACN,SAAS;wCAAC;4CAAE,MAAM;4CAAW,MAAM;wCAAU;qCAAE;oCAC/C,MAAM;gCACR;6BACD;4BACD,cAAc;4BACd,MAAM;gCAAC;6BAAuC;wBAChD;wBAEA,MAAM,mBAAmB,IAAA,8KAAW,EAAC,SAAS,8IAAa;wBAC3D,eAAe,WAAW,kBAAkB,OAAO,CAAC;oBACtD,EAAE,OAAO,OAAO;wBACd,eAAe;oBACjB,SAAU;wBACR,oBAAoB;oBACtB;gBACF;;YAEA,IAAI,iBAAiB,MAAM;gBACzB;YACF;QACF;qCAAG;QAAC;QAAe;KAAK;IAExB,OAAO;QAAE;QAAa;IAAiB;AACzC;GAvDa;;QACqB,sOAAQ"}},
    {"offset": {"line": 451, "column": 0}, "map": {"version":3,"sources":["file:///home/naufalfzml/Projects/Hackathon/dash-baseindo/dash-fe/src/hooks/wallet/useWalletActions.ts"],"sourcesContent":["import { usePrivy } from '@privy-io/react-auth';\nimport { toast } from 'sonner';\n\nexport const useWalletActions = () => {\n  const { user, exportWallet, logout } = usePrivy();\n\n  const getEmbeddedWalletAddress = () => {\n    const embeddedWallets = user?.linkedAccounts?.filter(\n      (account: any) =>\n        account.type === 'wallet' && account.imported === false && account.id !== undefined,\n    ) as any[];\n    return embeddedWallets?.[0]?.address || user?.wallet?.address;\n  };\n\n  const handleCopyAddress = () => {\n    const address = getEmbeddedWalletAddress();\n    if (address) {\n      navigator.clipboard.writeText(address);\n      toast.success('Address copied!');\n    }\n  };\n\n  const handleViewExplorer = () => {\n    const address = getEmbeddedWalletAddress();\n    if (address) {\n      window.open(`https://sepolia.basescan.org/address/${address}`, '_blank');\n    }\n  };\n\n  const handleExportPrivateKey = async () => {\n    try {\n      const embeddedWallets = user?.linkedAccounts?.filter(\n        (account: any) =>\n          account.type === 'wallet' && account.imported === false && account.id !== undefined,\n      ) as any[];\n\n      if (!embeddedWallets || embeddedWallets.length === 0) {\n        toast.error('Embedded wallet not found. Please reconnect your wallet.');\n        return;\n      }\n\n      const embeddedWalletAddress = embeddedWallets[0]?.address;\n      if (!embeddedWalletAddress) {\n        toast.error('Embedded wallet address not found');\n        return;\n      }\n\n      await exportWallet({ address: embeddedWalletAddress });\n      toast.success('Private key exported successfully!');\n    } catch (error: any) {\n      toast.error(error?.message || 'Failed to export private key');\n    }\n  };\n\n  const handleDisconnect = () => {\n    logout();\n    toast.success('Wallet disconnected');\n  };\n\n  const shortAddress = (() => {\n    const address = getEmbeddedWalletAddress();\n    return address\n      ? `${address.substring(0, 6)}...${address.substring(address.length - 4)}`\n      : 'Connected';\n  })();\n\n  return {\n    handleCopyAddress,\n    handleViewExplorer,\n    handleExportPrivateKey,\n    handleDisconnect,\n    shortAddress,\n    getEmbeddedWalletAddress,\n  };\n};\n"],"names":[],"mappings":";;;;AAAA;AACA;;;;AAEO,MAAM,mBAAmB;;IAC9B,MAAM,EAAE,IAAI,EAAE,YAAY,EAAE,MAAM,EAAE,GAAG,IAAA,sOAAQ;IAE/C,MAAM,2BAA2B;QAC/B,MAAM,kBAAkB,MAAM,gBAAgB,OAC5C,CAAC,UACC,QAAQ,IAAI,KAAK,YAAY,QAAQ,QAAQ,KAAK,SAAS,QAAQ,EAAE,KAAK;QAE9E,OAAO,iBAAiB,CAAC,EAAE,EAAE,WAAW,MAAM,QAAQ;IACxD;IAEA,MAAM,oBAAoB;QACxB,MAAM,UAAU;QAChB,IAAI,SAAS;YACX,UAAU,SAAS,CAAC,SAAS,CAAC;YAC9B,oJAAK,CAAC,OAAO,CAAC;QAChB;IACF;IAEA,MAAM,qBAAqB;QACzB,MAAM,UAAU;QAChB,IAAI,SAAS;YACX,OAAO,IAAI,CAAC,CAAC,qCAAqC,EAAE,SAAS,EAAE;QACjE;IACF;IAEA,MAAM,yBAAyB;QAC7B,IAAI;YACF,MAAM,kBAAkB,MAAM,gBAAgB,OAC5C,CAAC,UACC,QAAQ,IAAI,KAAK,YAAY,QAAQ,QAAQ,KAAK,SAAS,QAAQ,EAAE,KAAK;YAG9E,IAAI,CAAC,mBAAmB,gBAAgB,MAAM,KAAK,GAAG;gBACpD,oJAAK,CAAC,KAAK,CAAC;gBACZ;YACF;YAEA,MAAM,wBAAwB,eAAe,CAAC,EAAE,EAAE;YAClD,IAAI,CAAC,uBAAuB;gBAC1B,oJAAK,CAAC,KAAK,CAAC;gBACZ;YACF;YAEA,MAAM,aAAa;gBAAE,SAAS;YAAsB;YACpD,oJAAK,CAAC,OAAO,CAAC;QAChB,EAAE,OAAO,OAAY;YACnB,oJAAK,CAAC,KAAK,CAAC,OAAO,WAAW;QAChC;IACF;IAEA,MAAM,mBAAmB;QACvB;QACA,oJAAK,CAAC,OAAO,CAAC;IAChB;IAEA,MAAM,eAAe,CAAC;QACpB,MAAM,UAAU;QAChB,OAAO,UACH,GAAG,QAAQ,SAAS,CAAC,GAAG,GAAG,GAAG,EAAE,QAAQ,SAAS,CAAC,QAAQ,MAAM,GAAG,IAAI,GACvE;IACN,CAAC;IAED,OAAO;QACL;QACA;QACA;QACA;QACA;QACA;IACF;AACF;GAvEa;;QAC4B,sOAAQ"}},
    {"offset": {"line": 529, "column": 0}, "map": {"version":3,"sources":["file:///home/naufalfzml/Projects/Hackathon/dash-baseindo/dash-fe/src/hooks/wallet/useUSDCFaucet.tsx"],"sourcesContent":["import { useState } from 'react';\nimport { usePrivy, useWallets } from '@privy-io/react-auth';\nimport { encodeFunctionData } from 'viem';\nimport { toast } from 'sonner';\nimport { USDC_ADDRESS } from '@/config/contracts';\nimport React from 'react';\n\n// Mock USDC ABI with faucet function\nconst MOCK_USDC_ABI = [\n  {\n    inputs: [],\n    name: 'faucet',\n    outputs: [],\n    stateMutability: 'nonpayable',\n    type: 'function',\n  },\n  {\n    inputs: [\n      {\n        internalType: 'address',\n        name: '',\n        type: 'address',\n      },\n    ],\n    name: 'hasClaimed',\n    outputs: [\n      {\n        internalType: 'bool',\n        name: '',\n        type: 'bool',\n      },\n    ],\n    stateMutability: 'view',\n    type: 'function',\n  },\n] as const;\n\nexport const useUSDCFaucet = () => {\n  const { authenticated, user } = usePrivy();\n  const { wallets } = useWallets();\n  const [isClaiming, setIsClaiming] = useState(false);\n\n  const handleClaimUSDC = async () => {\n    if (!authenticated || !user) {\n      toast.error('Please connect your wallet first');\n      return;\n    }\n\n    const embeddedWallet = wallets.find((w) => w.walletClientType === 'privy');\n    if (!embeddedWallet) {\n      toast.error('Embedded wallet not found');\n      return;\n    }\n\n    const walletAddress = embeddedWallet.address;\n    setIsClaiming(true);\n    const loadingToast = toast.loading('Checking claim status...');\n\n    try {\n      const provider = await embeddedWallet.getEthereumProvider();\n      if (!provider) throw new Error('Could not get wallet provider');\n\n      // Check if user has already claimed\n      const hasClaimedData = encodeFunctionData({\n        abi: MOCK_USDC_ABI,\n        functionName: 'hasClaimed',\n        args: [walletAddress as `0x${string}`],\n      });\n\n      const hasClaimedResult = await provider.request({\n        method: 'eth_call',\n        params: [\n          {\n            to: USDC_ADDRESS,\n            data: hasClaimedData,\n          },\n          'latest',\n        ],\n      });\n\n      const alreadyClaimed =\n        hasClaimedResult !== '0x0000000000000000000000000000000000000000000000000000000000000000';\n\n      if (alreadyClaimed) {\n        toast.error(\n          'You have already claimed USDC from the faucet. Each wallet can only claim once.',\n          { id: loadingToast, duration: 5000 },\n        );\n        return;\n      }\n\n      toast.loading('Claiming USDC from faucet...', { id: loadingToast });\n\n      const data = encodeFunctionData({\n        abi: MOCK_USDC_ABI,\n        functionName: 'faucet',\n        args: [],\n      });\n\n      const txHash = await provider.request({\n        method: 'eth_sendTransaction',\n        params: [\n          {\n            from: walletAddress,\n            to: USDC_ADDRESS,\n            data: data,\n          },\n        ],\n      });\n\n      toast.success('USDC claimed successfully! ðŸŽ‰', {\n        id: loadingToast,\n        duration: 4000,\n      });\n\n      // Show transaction link\n      setTimeout(() => {\n        toast.success(\n          <div className=\"flex flex-col gap-1\">\n            <span>View on Explorer:</span>\n            <a\n              href={`https://sepolia.basescan.org/tx/${txHash}`}\n              target=\"_blank\"\n              rel=\"noopener noreferrer\"\n              className=\"underline text-blue-400 hover:text-blue-300\"\n            >\n              Click here\n            </a>\n          </div>,\n          { duration: 5000 },\n        );\n      }, 500);\n\n      // Reload the page to refresh balance\n      setTimeout(() => {\n        window.location.reload();\n      }, 2000);\n\n      return txHash;\n    } catch (error: any) {\n      let errorMessage = 'Failed to claim USDC from faucet';\n      if (error?.message?.includes('user rejected')) {\n        errorMessage = 'Transaction was rejected';\n      } else if (error?.message) {\n        errorMessage = error.message;\n      }\n      toast.error(errorMessage, { id: loadingToast });\n    } finally {\n      setIsClaiming(false);\n    }\n  };\n\n  return { isClaiming, handleClaimUSDC };\n};\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 714, "column": 0}, "map": {"version":3,"sources":["file:///home/naufalfzml/Projects/Hackathon/dash-baseindo/dash-fe/src/hooks/data/usePrices.ts"],"sourcesContent":["/**\n * Hook to fetch and manage real-time prices from backend\n * Uses WebSocket for instant real-time updates\n */\n\nimport { useState, useEffect } from 'react';\nimport { BACKEND_API_URL } from '@/config/contracts';\n\ninterface PriceData {\n  symbol: string;\n  price: number;\n  confidence: number;\n  timestamp: number;\n}\n\ninterface PricesState {\n  [symbol: string]: PriceData;\n}\n\nlet sharedPrices: PricesState = {};\nconst priceListeners: Set<() => void> = new Set();\nlet ws: WebSocket | null = null;\nlet reconnectTimeout: NodeJS.Timeout | null = null;\n\n// WebSocket connection\nfunction connectWebSocket() {\n  if (ws && ws.readyState === WebSocket.OPEN) {\n    return; // Already connected\n  }\n\n  try {\n    // Convert http/https to ws/wss\n    const wsUrl = BACKEND_API_URL.replace(/^http/, 'ws') + '/ws/price';\n\n    ws = new WebSocket(wsUrl);\n\n    ws.onopen = () => {};\n\n    ws.onmessage = (event) => {\n      try {\n        const data = JSON.parse(event.data);\n\n        if (data.type === 'price_update' && data.data) {\n          // Update all prices at once (backend uses 'data' field)\n          sharedPrices = data.data;\n\n          // Notify all listeners\n          priceListeners.forEach((listener) => listener());\n        }\n      } catch (error) {}\n    };\n\n    ws.onerror = (error) => {};\n\n    ws.onclose = () => {\n      ws = null;\n\n      // Reconnect after 2 seconds\n      reconnectTimeout = setTimeout(() => {\n        if (priceListeners.size > 0) {\n          connectWebSocket();\n        }\n      }, 2000);\n    };\n  } catch (error) {}\n}\n\n// Start WebSocket if not already started\nfunction startPriceStream() {\n  connectWebSocket();\n\n  // Also fetch initial prices via REST as fallback\n  fetch(`${BACKEND_API_URL}/api/price/all`)\n    .then((res) => res.json())\n    .then((result) => {\n      if (result.success && result.data) {\n        sharedPrices = result.data;\n        priceListeners.forEach((listener) => listener());\n      }\n    })\n    .catch((err) => {});\n}\n\n// Stop WebSocket if no more listeners\nfunction stopPriceStream() {\n  if (priceListeners.size === 0) {\n    if (ws) {\n      ws.close();\n      ws = null;\n    }\n    if (reconnectTimeout) {\n      clearTimeout(reconnectTimeout);\n      reconnectTimeout = null;\n    }\n  }\n}\n\n/**\n * Hook to get current price for a specific symbol\n */\nexport function usePrice(symbol: string | undefined) {\n  const [price, setPrice] = useState<PriceData | null>(\n    symbol && sharedPrices[symbol] ? sharedPrices[symbol] : null,\n  );\n  const [isLoading, setIsLoading] = useState(true);\n\n  useEffect(() => {\n    if (!symbol) {\n      setIsLoading(false);\n      return;\n    }\n\n    // Update function\n    const updatePrice = () => {\n      const currentPrice = sharedPrices[symbol];\n      if (currentPrice) {\n        setPrice(currentPrice);\n        setIsLoading(false);\n      }\n    };\n\n    // Add listener\n    priceListeners.add(updatePrice);\n\n    // Start WebSocket stream\n    startPriceStream();\n\n    // Initial update\n    updatePrice();\n\n    // Cleanup\n    return () => {\n      priceListeners.delete(updatePrice);\n      stopPriceStream();\n    };\n  }, [symbol]);\n\n  return { price, isLoading };\n}\n\n/**\n * Hook to get all current prices\n */\nexport function useAllPrices() {\n  const [prices, setPrices] = useState<PricesState>(sharedPrices);\n  const [isLoading, setIsLoading] = useState(true);\n\n  useEffect(() => {\n    const updatePrices = () => {\n      setPrices({ ...sharedPrices });\n      setIsLoading(false);\n    };\n\n    priceListeners.add(updatePrices);\n    startPriceStream();\n    updatePrices();\n\n    return () => {\n      priceListeners.delete(updatePrices);\n      stopPriceStream();\n    };\n  }, []);\n\n  return { prices, isLoading };\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 870, "column": 0}, "map": {"version":3,"sources":["file:///home/naufalfzml/Projects/Hackathon/dash-baseindo/dash-fe/src/hooks/utils/useDynamicTitle.ts"],"sourcesContent":["import { useEffect } from 'react';\n\nexport const useDynamicTitle = (price: number | null, pair: string) => {\n  useEffect(() => {\n    if (price !== null && !isNaN(price)) {\n      document.title = `${price.toLocaleString('en-US', {\n        minimumFractionDigits: 1,\n        maximumFractionDigits: 1\n      })} | ${pair} | Trade | Dash`;\n    } else {\n      document.title = 'Dash';\n    }\n  }, [price, pair]);\n};\n"],"names":[],"mappings":";;;;AAAA;;;AAEO,MAAM,kBAAkB,CAAC,OAAsB;;IACpD,IAAA,0KAAS;qCAAC;YACR,IAAI,UAAU,QAAQ,CAAC,MAAM,QAAQ;gBACnC,SAAS,KAAK,GAAG,GAAG,MAAM,cAAc,CAAC,SAAS;oBAChD,uBAAuB;oBACvB,uBAAuB;gBACzB,GAAG,GAAG,EAAE,KAAK,eAAe,CAAC;YAC/B,OAAO;gBACL,SAAS,KAAK,GAAG;YACnB;QACF;oCAAG;QAAC;QAAO;KAAK;AAClB;GAXa"}},
    {"offset": {"line": 903, "column": 0}, "map": {"version":3,"sources":["file:///home/naufalfzml/Projects/Hackathon/dash-baseindo/dash-fe/src/lib/utils.ts"],"sourcesContent":["import { clsx, type ClassValue } from \"clsx\"\nimport { twMerge } from \"tailwind-merge\"\n\nexport function cn(...inputs: ClassValue[]) {\n  return twMerge(clsx(inputs))\n}\n"],"names":[],"mappings":";;;;AAAA;AACA;;;AAEO,SAAS,GAAG,GAAG,MAAoB;IACxC,OAAO,IAAA,yKAAO,EAAC,IAAA,gJAAI,EAAC;AACtB"}},
    {"offset": {"line": 921, "column": 0}, "map": {"version":3,"sources":["file:///home/naufalfzml/Projects/Hackathon/dash-baseindo/dash-fe/src/lib/priceApi.ts"],"sourcesContent":["/**\n * Price API Utilities\n * Handle communication with backend for signed prices\n */\n\nimport { BACKEND_API_URL } from '@/config/contracts';\n\nexport interface SignedPriceData {\n  asset: string; // Asset symbol (e.g., \"BTC\")\n  assetId: string; // keccak256 hash of asset symbol\n  price: string; // Price with 8 decimals as string\n  timestamp: number;\n  signature: string;\n  signer: string; // Signer address\n\n  // Backward compatibility\n  symbol?: string;\n}\n\nexport interface SignedPriceResponse {\n  success: boolean;\n  data?: SignedPriceData;\n  error?: string;\n}\n\n/**\n * Get signed price from backend\n * @param symbol Asset symbol (BTC, ETH, etc)\n * @returns Signed price data\n */\nexport async function getSignedPrice(symbol: string): Promise<SignedPriceData> {\n  try {\n    const response = await fetch(`${BACKEND_API_URL}/api/price/signed/${symbol}`, {\n      method: 'GET',\n      headers: {\n        'Content-Type': 'application/json',\n      },\n    });\n\n    if (!response.ok) {\n      throw new Error(`Failed to get signed price: ${response.statusText}`);\n    }\n\n    const result: SignedPriceResponse = await response.json();\n\n    if (!result.success || !result.data) {\n      throw new Error(result.error || 'Failed to get signed price');\n    }\n\n    return result.data;\n  } catch (error) {\n    throw error;\n  }\n}\n"],"names":[],"mappings":"AAAA;;;CAGC;;;;AAED;;AAyBO,eAAe,eAAe,MAAc;IACjD,IAAI;QACF,MAAM,WAAW,MAAM,MAAM,GAAG,gJAAe,CAAC,kBAAkB,EAAE,QAAQ,EAAE;YAC5E,QAAQ;YACR,SAAS;gBACP,gBAAgB;YAClB;QACF;QAEA,IAAI,CAAC,SAAS,EAAE,EAAE;YAChB,MAAM,IAAI,MAAM,CAAC,4BAA4B,EAAE,SAAS,UAAU,EAAE;QACtE;QAEA,MAAM,SAA8B,MAAM,SAAS,IAAI;QAEvD,IAAI,CAAC,OAAO,OAAO,IAAI,CAAC,OAAO,IAAI,EAAE;YACnC,MAAM,IAAI,MAAM,OAAO,KAAK,IAAI;QAClC;QAEA,OAAO,OAAO,IAAI;IACpB,EAAE,OAAO,OAAO;QACd,MAAM;IACR;AACF"}},
    {"offset": {"line": 957, "column": 0}, "map": {"version":3,"sources":["file:///home/naufalfzml/Projects/Hackathon/dash-baseindo/dash-fe/src/lib/relayApi.ts"],"sourcesContent":["/**\n * API client for gasless transaction relay service\n */\n\nimport { BACKEND_API_URL } from '@/config/contracts';\n\nexport interface RelayTransactionParams {\n  to: string;\n  data: string;\n  userAddress: string;\n  value?: string;\n}\n\nexport interface RelayTransactionResult {\n  txHash: string;\n  gasUsed: string;\n  usdcCharged: string;\n  usdcChargedFormatted: string;\n  explorerUrl: string;\n}\n\nexport interface GasCostEstimate {\n  estimatedGas: string;\n  usdcCost: string;\n  usdcCostFormatted: string;\n}\n\nexport interface AffordabilityCheck {\n  canAfford: boolean;\n  userDeposit: string;\n  requiredUsdc: string;\n  depositFormatted: string;\n  requiredFormatted: string;\n}\n\nexport interface LimitExecutionFeeEstimate {\n  orderType: string;\n  gasEstimate: string;\n  baseCost: string;\n  baseCostFormatted: string;\n  bufferBps: number;\n  recommendedMaxExecutionFee: string;\n  recommendedFormatted: string;\n}\n\n/**\n * Relay a transaction through backend (gasless)\n */\nexport async function relayTransaction(\n  params: RelayTransactionParams,\n): Promise<RelayTransactionResult> {\n  const response = await fetch(`${BACKEND_API_URL}/api/relay/transaction`, {\n    method: 'POST',\n    headers: {\n      'Content-Type': 'application/json',\n    },\n    body: JSON.stringify(params),\n  });\n\n  const result = await response.json();\n\n  if (!result.success) {\n    throw new Error(result.error || result.message || 'Failed to relay transaction');\n  }\n\n  return result.data;\n}\n\n/**\n * Get recommended execution fee for limit orders\n */\nexport async function getLimitExecutionFee(\n  orderType: 'limit_open' | 'limit_close' | 'stop_loss' = 'limit_open',\n  options: { estimatedGas?: string; bufferBps?: number } = {},\n): Promise<LimitExecutionFeeEstimate> {\n  const params = new URLSearchParams({ orderType });\n\n  if (options.estimatedGas) {\n    params.set('estimatedGas', options.estimatedGas);\n  }\n\n  if (options.bufferBps !== undefined) {\n    params.set('bufferBps', options.bufferBps.toString());\n  }\n\n  const response = await fetch(\n    `${BACKEND_API_URL}/api/relay/limit/execution-fee?${params.toString()}`,\n  );\n  const result = await response.json();\n\n  if (!result.success) {\n    throw new Error(result.error || 'Failed to estimate execution fee');\n  }\n\n  return result.data;\n}\n"],"names":[],"mappings":"AAAA;;CAEC;;;;;;AAED;;AA4CO,eAAe,iBACpB,MAA8B;IAE9B,MAAM,WAAW,MAAM,MAAM,GAAG,gJAAe,CAAC,sBAAsB,CAAC,EAAE;QACvE,QAAQ;QACR,SAAS;YACP,gBAAgB;QAClB;QACA,MAAM,KAAK,SAAS,CAAC;IACvB;IAEA,MAAM,SAAS,MAAM,SAAS,IAAI;IAElC,IAAI,CAAC,OAAO,OAAO,EAAE;QACnB,MAAM,IAAI,MAAM,OAAO,KAAK,IAAI,OAAO,OAAO,IAAI;IACpD;IAEA,OAAO,OAAO,IAAI;AACpB;AAKO,eAAe,qBACpB,YAAwD,YAAY,EACpE,UAAyD,CAAC,CAAC;IAE3D,MAAM,SAAS,IAAI,gBAAgB;QAAE;IAAU;IAE/C,IAAI,QAAQ,YAAY,EAAE;QACxB,OAAO,GAAG,CAAC,gBAAgB,QAAQ,YAAY;IACjD;IAEA,IAAI,QAAQ,SAAS,KAAK,WAAW;QACnC,OAAO,GAAG,CAAC,aAAa,QAAQ,SAAS,CAAC,QAAQ;IACpD;IAEA,MAAM,WAAW,MAAM,MACrB,GAAG,gJAAe,CAAC,+BAA+B,EAAE,OAAO,QAAQ,IAAI;IAEzE,MAAM,SAAS,MAAM,SAAS,IAAI;IAElC,IAAI,CAAC,OAAO,OAAO,EAAE;QACnB,MAAM,IAAI,MAAM,OAAO,KAAK,IAAI;IAClC;IAEA,OAAO,OAAO,IAAI;AACpB"}},
    {"offset": {"line": 1005, "column": 0}, "map": {"version":3,"sources":["file:///home/naufalfzml/Projects/Hackathon/dash-baseindo/dash-fe/src/lib/limitOrderApi.ts"],"sourcesContent":["import { BACKEND_API_URL } from '@/config/contracts';\n\nexport interface LimitOpenOrderRequest {\n  trader: string;\n  symbol: string;\n  isLong: boolean;\n  collateral: string; // base units (USDC 6 decimals)\n  leverage: string; // integer string\n  triggerPrice: string; // base units (8 decimals)\n  nonce: string;\n  expiresAt: string;\n  signature: `0x${string}`;\n  takeProfit?: string; // optional TP price (8 decimals)\n  stopLoss?: string; // optional SL price (8 decimals)\n  metadata?: {\n    collateralUsd?: string;\n    triggerPriceUsd?: string;\n  };\n}\n\nexport interface LimitOrderSubmissionResponse {\n  orderId: string;\n  txHash: string;\n  explorerUrl?: string;\n}\n\nexport async function submitLimitOpenOrder(\n  payload: LimitOpenOrderRequest\n): Promise<LimitOrderSubmissionResponse> {\n  const response = await fetch(`${BACKEND_API_URL}/api/limit-orders/create`, {\n    method: 'POST',\n    headers: {\n      'Content-Type': 'application/json',\n    },\n    body: JSON.stringify(payload),\n  });\n\n  const result = await response.json();\n\n  if (!response.ok || !result.success) {\n    throw new Error(result.error || result.message || 'Failed to submit limit order');\n  }\n\n  return result.data as LimitOrderSubmissionResponse;\n}\n"],"names":[],"mappings":";;;;AAAA;;AA0BO,eAAe,qBACpB,OAA8B;IAE9B,MAAM,WAAW,MAAM,MAAM,GAAG,gJAAe,CAAC,wBAAwB,CAAC,EAAE;QACzE,QAAQ;QACR,SAAS;YACP,gBAAgB;QAClB;QACA,MAAM,KAAK,SAAS,CAAC;IACvB;IAEA,MAAM,SAAS,MAAM,SAAS,IAAI;IAElC,IAAI,CAAC,SAAS,EAAE,IAAI,CAAC,OAAO,OAAO,EAAE;QACnC,MAAM,IAAI,MAAM,OAAO,KAAK,IAAI,OAAO,OAAO,IAAI;IACpD;IAEA,OAAO,OAAO,IAAI;AACpB"}},
    {"offset": {"line": 1032, "column": 0}, "map": {"version":3,"sources":["file:///home/naufalfzml/Projects/Hackathon/dash-baseindo/dash-fe/src/app/trade/page.tsx"],"sourcesContent":["'use client';\r\n\r\nimport { MarketProvider } from '@/features/trading/contexts/MarketContext';\r\nimport { GridTradingProvider } from '@/contexts/GridTradingContext';\r\nimport { TapToTradeProvider } from '@/features/trading/contexts/TapToTradeContext';\r\nimport TradePageContent from '@/features/trading/components/trade-content/TradePageContent';\r\n\r\nexport default function TradePage() {\r\n  return (\r\n    <MarketProvider>\r\n      <GridTradingProvider>\r\n        <TapToTradeProvider>\r\n          <TradePageContent />\r\n        </TapToTradeProvider>\r\n      </GridTradingProvider>\r\n    </MarketProvider>\r\n  );\r\n}\r\n"],"names":[],"mappings":";;;;;AAEA;AACA;AACA;AACA;AALA;;;;;;AAOe,SAAS;IACtB,qBACE,6LAAC,6KAAc;kBACb,cAAA,6LAAC,gKAAmB;sBAClB,cAAA,6LAAC,qLAAkB;0BACjB,cAAA,6LAAC,+LAAgB;;;;;;;;;;;;;;;;;;;;AAK3B;KAVwB"}}]
}